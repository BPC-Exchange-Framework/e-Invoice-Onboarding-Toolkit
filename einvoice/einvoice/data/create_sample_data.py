#!/usr/bin/env python3
#
# File: create_sample_data.py
# About: Create test e-Invoices using fake data sets.  
# Development: Kelly Kinney
# Date: 2021-06-22 (June 22, 2021)
#
"""
Classes and functions to generate sample/test e-Invoices.

Test data is generated in two ways.
1. Loaded into TinyDB from CSV files.
2. Additonal dummy data is genearted on the fly by the Faker package.
Data generated by Faker is new every run. Data sets from the CSV files
are static.
Data items are combined into an e-Invoice line item and stored as a list.
The output of this sample list of line items is writen to a JSON file.

    Usage:
    genLI = generateLineItems()
    genLI.

"""
from faker import Faker
import csv
import random
import logging
from json import dumps

# Create a logger.
FORMAT='%(asctime)s - $(levelname)s - $(funcName)s - $(message)s'
DATEFMT='%m/%d/%Y %I:%M:%S %p'
logging.basicConfig(format=FORMAT, datefmt=DATEFMT, level=logging.INFO)


class CreateSampleData:

    def __init__(self):
        logging.info("Generating e-Invoice Data!")
    """An instance of the CreateSampleData object.  

    The job of this class/object is to generate sample data for
    an e-Invoice.

    Args:

    Attributes:
        Items[]: A list of line_items to populate an e-Invoice.  Populated by
            reading in from a CSV file.
        PerItem[]: A list of item sizes/groups/types to populate an e-Invoice.  
            Populated by reading in from a CSV file.

    Returns:

    Raises:
    """

    # Read the CSV files in

    Items = []
    with open('./item_list.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            Items.append(row)

    PerItem = []
    with open('./per_item_list.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            PerItem.append(row)


    fake = Faker()
    Faker.seed(0)

    def generateFakeCo(_count=1):
        """Generate as many fake addresses as requested.

        Args:
            _count:
                The number of addresses reqested.

        Raises:

        Returns:
            A list of JSON entries with each one representing an
            address.
        """

        companies = []

        for _ in range (_count):
            orgID = fake.bothify(text='????-######',
                letters='ACDEFGHIJKLMNOPQRSQSTeUVWXYZ')
            name = fake.company()
            addr_1 = "Attn: " + fake.name()
            addr_2 = fake.street_address()
            city = fake.city()
            state = fake.state()
            zip = fake.postcode()

            # Create a JSON string of the Company.
            company = str({'orgID': orgID, "name": name, "addr_1":addr_1,
                "addr_2":addr_2, "city":city, "state":state, "zip":zip})

            companies.append(company)

            logging.debug("Created a data for comapny: " + company)

        return companies


    def create_sample_list_items(_count=1):
        """Generate as many fake line_items as requested.
        
        Args:
            _count:
                The number of line_items reqested.

        Raises:

        Returns:
            A list of JSON entries with each one representing a line item.
        """

        line_items = []

        for _ in range (_count):
            line_iten_id = fake.bothify(text='??????-###',
                letters='ACDEFGHIJKLMNOPQRSQSTeUVWXYZ')
            line_item_quantity = random.randint(1,10)
            line_item_per_item = random.choice(PerItem)
            line_item_price_per_item = (random.randint(100, 10000))/100
            line_item_name = random.choice(Items)
            line_item_total = line_item_quantity * line_item_price_per_item
            
            # Create a JSON string of the sample_line_item
            sample_line_item = str({'Item ID':line_iten_id, 'Quantity':line_item_quantity,
                'Per Item':line_item_per_item, 'Price per Item':line_item_price_per_item, 'Item':line_item_name,
                'Total':line_item_total})

            line_items.append(sample_line_item)

            logging.debug("Created line item entry: " + sample_line_item)

        return line_items


    def write_json_to_file(_object):
        if len(_object) < 1:
            logging.warn("Do you WANT an index out of bounds " 
                "error, cuz you're just asking for one.")
            return
        
        for i in range(len(_object)):
            jsonStr = dumps(_object[i].__dict__)
            logging.debug("List item " + str(i) + ": " + jsonStr)
            print(jsonStr)
